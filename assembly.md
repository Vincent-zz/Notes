# 汇编 

## 基础知识 

### 计算机基础 

主板（核心器件为CPU）控制接口卡（如显卡、网卡）控制外部器件（如显示器） 

**CPU -> 内存**： 
- 地址总线：在内存中寻找指定地址，n位地址总线 <=> n条线 <=> 宽度为n <=> 可以寻找2^n个内存单元（一内存单元 = 1 Byte），地址总线所能寻到的地址即为内存地址空间
- 控制总线：传输读、写等控制，越宽则能传输的控制越多，控制能力越强
- 数据总线：CPU与内存之间传送数据，越宽速度越快

三条总线与CPU内部输入输出控制器相连 

### 内存 

**内存的组成——存储器**:
- RAM：随机存储器（断电后数据会遗失）
- ROM：只读存储器（装有BIOS：Basic Input/Output System，硬件的基本输入输出程序，主板、某些接口卡都有这样的程序）
CPU通过地址总线连接主板、接口卡中的存储器 

所有内存单元构成的储存空间是一维线性的，且对于数据而言是从低位到高位的，例： 

`mov ax,0123H`这句汇编代码在内存中储存的形式是：B8（B8表示mov ax，假设此地址为10000），23（地址：10001），01（地址：10002）

此时，0123H为内存地址10001上储存的字型数据（1 word = 2 Byte） 

**段**： 

提高寻址能力，以8086（16位CPU）为例，8086有20位数据总线，CPU内部采用两个16位地址（段地址、偏移地址）通过地址加法器合成20位地址后输出到地址总线 

`内存地址 = 段地址 * 16 + 偏移地址`，可以表示为“段地址:偏移地址”的形式，同一个内存物理地址可以有多种分解方式 

### CPU 

**CPU的组成**：
- 运算器：n位CPU的运算器一次可处理n位的数据
- 控制器：控制CPU内各器件的工作
- 寄存器：n位CPU的通用寄存器宽度为n位，寄存器与运算器之间的通路是n位的
 
通过内部总线连接 

## 寄存器 

### 通用寄存器 

通用寄存器：AX、BX、CX、DX（16位，可存储一个字） 

两个独立8位寄存器使用（为了向下兼容），例如AX可以分为AH（high）、AL（low） 

### 段寄存器、指针寄存器 

段寄存器、指令指针寄存器：CS（code）、DS（data）、SS（stack）、ES（extra）；IP（instructor point）、SP（stack point） 

CPU访问内存时由段以及指针提供地址  

**CS:IP** 

指令汇编代码储存在内存中，CPU利用CS:IP提供的地址合成指令代码入口处的内存物理地址（(CS) * 16 + IP），读入指令到指令缓冲器，CPU的执行控制器执行缓冲器中的指令，并且使CS:IP指向下一条指令代码的位置（(IP) += 所读取指令长度），循环往复 

通过转移指令jmp改变CS:IP的值： 

`jmp 段地址:偏移地址` 

仅改变IP的值（通过其他寄存器的值）： 

```
mov ax,偏移地址
jmp ax 
``` 

\* 开机时，CS:IP被初始化 

**DS** 

DS用于存放要访问的数据的段地址，搭配mov指令可以实现对内存中数据的读取和写入： 

```
mov bx,段地址
mov ds,bx
mov al,[偏移地址]   ; 读取一个内存单元的数据到al中
mov [偏移地址],al   ; 将al中的数据写入一个内存单元
mov ax,[偏移地址]   ; 读取指定地址的字型数据到ax中
mov [偏移地址],ax   ; 将ax中的字型数据写入指定地址

mov bx,偏移地址
mov ax,[bx]         ;先将偏移地址存入寄存器中的写法
``` 

\* `mov`指令不支持直接将数据存入段寄存器 

**SS:SP** 

栈是一种对内存空间的特殊访问形式 

\* 将一段连续内存视为栈时以高位为栈底，低位为栈顶，初始时SS:SP指向栈底的后一位内存单元 

SS:SP提供栈顶的地址，相关指令如下： 

```
mov ax 栈的段地址
mov ss ax
mov sp 起始偏移地址

push 寄存器 ;将(SP)-=2，寄存器中的值（一个字）移入栈顶
push [偏移地址] ;(SP)-=2，将内存单元中的值（一个字）移入栈顶
pop 寄存器  ;将栈顶处的字型数据移入寄存器，同时(SP)+=2
pop [偏移地址]  ;将栈顶处的字型数据移入内存单元，同时(SP)+=2
``` 

\* 栈顶超界是CPU无法解决的，必须在写代码时人工确认，保证对栈的操作不会越界 

## 程序 

### 源程序处理 

1、**编写**： 

产生一个储存了源程序的文本文件 

2、**编译、链接**： 

生成可执行文件（`.com`、`.exe`） 

可执行文件包括： 

- 程序和数据：汇编指令机器码和源程序中定义的数据
- 描述信息：程序相关信息，如占用内存空间的大小等

3、**执行**： 

将可执行文件内的机器码与数据加载入内存，初始化（比如设置CS:IP等），CPU执行程序代码 

### 源程序 

**源程序组成**
- 伪指令
- 汇编指令

**程序返回**： 

对于单任务的DOS系统，正在运行的程序（dos系统的shell）把将要执行的程序加载入内存，再使CPU执行这个程序，执行完后要返回shell 

为实现程序返回，在每个程序的末端都应加上如下汇编指令： 

```
mov ax,4c00h
int 21h
``` 

### DOS中可执行文件（.exe）的加载过程 

1、找到一段起始位置为SA:0000的容量足够大的空闲区域 

2、SA:0000到SA：00FF（256B）存放程序段前缀（PSP）用于与DOS系统通信 

3、将之后的空间视为一个新的段，(SA+10H):0000为起始位置，存入可执行文件中的程序机器码 

4、初始化相关寄存器：(DS) = SA，CS:IP指向(SA+10H):0000，CX中存放了这个程序的长度... 

### 一些伪指令语法

```
assume 寄存器:段名   ;假设段与寄存器的关联
段名 segment        ;定义段，这个段名在编译链接之后会指向一个地址

入口名:              ;表示程序入口，即初始时CS:IP指向的位置
    ...             ;段的内容

段名 ends           ;结束段，与定义段成对使用
end 入口名           ;end提示编译器结束编译
``` 

定义段用于存放代码/存放数据/作为栈使用，一个有意义的汇编程序至少有一个段 

### 一些简单汇编指令语法 

```
mov ax,bx   ;(ax) = (bx)
add ax,bx   ;(ax) += (bx)
sub ax,bx   ;(ax) -= (bx)
inc ax      ;(ax)++
``` 

### \[bx\]与loop 

**loop指令** 

```
mov cx 循环次数     ;cx与loop指令有特殊的关系，每轮循环后(cx)--，到(cx) == 0为止
循环名: 
...                 ;要循环的语句 
loop 循环名         ;固定格式
``` 

操作流程：循环名标记了循环起始地址，当程序运行到loop时，执行(cx)--
- 若(cx) != 0，CS:IP指向相应循环名标记的地址
- 若(cx) == 0，继续向下执行后续指令